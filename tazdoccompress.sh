#!/bin/bash

# tazdoccompress - A script for maximal, high-quality PDF compression on Arch Linux.
#
# Author: Taz (Generated by AI)
# Version: 3.0 - Directory Processing Edition
#
# Features:
# - Compresses a single PDF file (legacy mode).
# - Processes an entire directory:
#   - Converts .doc, .docx, .png, .jpg, .jpeg, .tiff to PDF.
#   - Merges all documents into a single PDF, respecting natural sort order.
#   - Compresses the final merged PDF.
# - Optionally packages the final result into a ZIP archive.
# - Uses a safe, temporary directory for all intermediate work.

# --- Default Configuration ---
DEFAULT_DPI="150"

# --- Style/Color Definitions ---
C_RESET='\033[0m'
C_RED='\033[0;31m'
C_GREEN='\033[0;32m'
C_YELLOW='\033[0;33m'
C_BLUE='\033[0;34m'
C_BOLD='\033[1m'

# --- Usage/Help Function ---
show_usage() {
    echo -e "${C_BOLD}Taz's Document Compressor v3.0${C_RESET}"
    echo "A tool for high-quality PDF compression and directory packaging."
    echo
    echo -e "${C_BOLD}Usage:${C_RESET} tazdoccompress [options] <input>"
    echo
    echo -e "${C_BOLD}Modes:${C_RESET}"
    echo "  ${C_BLUE}Single File Mode:${C_RESET} Provide a PDF file as input."
    echo "    tazdoccompress [options] my_document.pdf"
    echo "  ${C_BLUE}Directory Mode:${C_RESET} Provide a directory as input."
    echo "    tazdoccompress [options] /path/to/my_folder"
    echo
    echo -e "${C_BOLD}Options:${C_RESET}"
    echo -e "  ${C_YELLOW}-z, --zip${C_RESET}         Package the final compressed PDF into a .zip archive."
    echo -e "  ${C_YELLOW}-d, --dpi <NUM>${C_RESET}  Set the image resolution in DPI for compression (default: ${DEFAULT_DPI})."
    echo -e "  ${C_YELLOW}-h, --help${C_RESET}        Show this help message."
}


# --- Dependency Check ---
check_deps() {
    echo -e "${C_BLUE}Checking dependencies...${C_RESET}"
    local missing_deps=0
    # Add libreoffice, convert (imagemagick), and pdfunite (poppler)
    # Note: libreoffice binary can be 'libreoffice' or 'soffice'
    local libreoffice_cmd="libreoffice"
    if ! command -v "$libreoffice_cmd" &> /dev/null; then
        libreoffice_cmd="soffice" # Fallback for some installations
    fi

    for cmd in ocrmypdf gs zip "$libreoffice_cmd" convert pdfunite; do
        if ! command -v "$cmd" &> /dev/null; then
            echo -e "${C_RED}Error: Required command '${C_BOLD}${cmd}${C_RED}' is not found.${C_RESET}"
            missing_deps=1
        fi
    done

    if [[ "$missing_deps" -eq 1 ]]; then
        echo -e "${C_YELLOW}Please install the necessary packages on Arch Linux with:${C_RESET}"
        echo "sudo pacman -S ocrmypdf ghostscript zip libreoffice-fresh imagemagick poppler"
        exit 1
    fi
    echo -e "${C_GREEN}All dependencies are installed.${C_RESET}"
}

# --- Compression Logic (for single or merged PDF) ---
compress_pdf() {
    local input_pdf="$1"
    local output_pdf="$2"
    local dpi="$3"
    
    echo -e "\n${C_BLUE}--- Starting Final Compression Stage ---${C_RESET}"
    echo -e "Input for compression: ${C_BOLD}${input_pdf}${C_RESET}"
    echo -e "Using target resolution: ${C_YELLOW}${dpi} DPI${C_RESET}"

    if ! ocrmypdf \
        --output-type pdf \
        --optimize 3 \
        --skip-text \
        --image-dpi "${dpi}" \
        "${input_pdf}" \
        "${output_pdf}"; then
        echo -e "\n${C_RED}Error: Final PDF compression failed. See output above.${C_RESET}"
        return 1
    fi
    return 0
}

# --- Directory Processing Logic ---
process_directory() {
    local input_dir="$1"
    local dpi="$2"
    local do_zip="$3"
    local output_basename
    output_basename=$(basename "${input_dir}")
    
    # Create a temporary working directory
    local WORK_DIR
    WORK_DIR=$(mktemp -d -t tazdoccompress-XXXXXX)
    # Ensure cleanup on script exit, even on error
    trap 'echo -e "${C_YELLOW}Cleaning up temporary files..."; rm -rf "$WORK_DIR";' EXIT

    echo -e "\n${C_BLUE}--- Starting Directory Processing ---${C_RESET}"
    echo "Source Directory: ${C_BOLD}${input_dir}${C_RESET}"
    echo "Working Directory: ${WORK_DIR}"

    # Find, sort, and convert all processable files
    echo -e "\n${C_BLUE}Step 1: Finding and converting files...${C_RESET}"
    local file_list=()
    # Use find and process substitution with a while loop for robust file handling
    while IFS= read -r -d '' file; do
        file_list+=("$file")
    done < <(find "${input_dir}" -maxdepth 1 -type f \( \
        -iname "*.pdf" -o -iname "*.doc" -o -iname "*.docx" \
        -o -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" \
        -o -iname "*.tiff" \) -print0 | sort -zV) # -z for null separator, -V for natural sort

    if [[ ${#file_list[@]} -eq 0 ]]; then
        echo -e "${C_RED}Error: No processable files found in directory.${C_RESET}"
        exit 1
    fi

    echo "Found ${#file_list[@]} files to process."
    local converted_pdfs=()
    for file in "${file_list[@]}"; do
        local fname; fname=$(basename "$file")
        echo -n "  - Processing ${fname}..."
        local ext="${fname##*.}"
        local base="${fname%.*}"
        local converted_pdf_path="${WORK_DIR}/${base}.pdf"
        
        case "${ext,,}" in # to lower case
            pdf)
                cp "${file}" "${converted_pdf_path}"
                echo -e " ${C_GREEN}(Copied)${C_RESET}"
                ;;
            doc|docx)
                # Use soffice as it's the underlying binary for libreoffice
                soffice --headless --convert-to pdf --outdir "${WORK_DIR}" "${file}" &>/dev/null
                # LibreOffice keeps the original basename
                mv "${WORK_DIR}/${base}.pdf" "${converted_pdf_path}"
                echo -e " ${C_GREEN}(Converted)${C_RESET}"
                ;;
            png|jpg|jpeg|tiff)
                convert "${file}" "${converted_pdf_path}" &>/dev/null
                echo -e " ${C_GREEN}(Converted)${C_RESET}"
                ;;
        esac
        # Check if conversion was successful
        if [[ -f "${converted_pdf_path}" ]]; then
             converted_pdfs+=("${converted_pdf_path}")
        else
            echo -e " ${C_RED}FAIL! Conversion failed for this file.${C_RESET}"
        fi
    done
    
    # Merge all the generated PDFs
    echo -e "\n${C_BLUE}Step 2: Merging ${#converted_pdfs[@]} PDFs...${C_RESET}"
    local merged_unopt_pdf="${WORK_DIR}/merged.unoptimized.pdf"
    if ! pdfunite "${converted_pdfs[@]}" "${merged_unopt_pdf}"; then
        echo -e "${C_RED}Error: Failed to merge PDFs with pdfunite.${C_RESET}"
        exit 1
    fi
    echo "Merge successful."
    
    # Compress the single merged PDF
    local final_output_file="${output_basename}.compressed.pdf"
    if [[ -f "${final_output_file}" ]]; then
        echo -e "${C_RED}Error: Output file '${final_output_file}' already exists. Please remove it first.${C_RESET}"
        exit 1
    fi

    if ! compress_pdf "${merged_unopt_pdf}" "${final_output_file}" "${dpi}"; then
        rm -f "${final_output_file}" # Clean up failed output
        exit 1
    fi

    # Final reporting and packaging
    local original_size; original_size=$(du -sb "${input_dir}" | cut -f1)
    local compressed_size; compressed_size=$(stat -c%s "${final_output_file}")
    
    report_and_zip "${original_size}" "${compressed_size}" "${final_output_file}" "$do_zip"
}

# --- Single File Processing Logic ---
process_single_file() {
    local input_file="$1"
    local dpi="$2"
    local do_zip="$3"

    if ! file "$input_file" | grep -q "PDF document"; then
        echo -e "${C_RED}Error: Input file does not appear to be a PDF.${C_RESET}"
        echo "For directory processing, please provide the directory path as input."
        exit 1
    fi
    
    local output_file="${input_file%.*}.compressed.pdf"
    if [[ -f "$output_file" ]]; then
        echo -e "${C_RED}Error: Output file already exists: ${C_BOLD}${output_file}${C_RESET}"
        exit 1
    fi

    if ! compress_pdf "${input_file}" "${output_file}" "${dpi}"; then
        rm -f "${output_file}"
        exit 1
    fi

    local original_size; original_size=$(stat -c%s "${input_file}")
    local compressed_size; compressed_size=$(stat -c%s "${output_file}")
    
    report_and_zip "${original_size}" "${compressed_size}" "${output_file}" "$do_zip"
}

# --- Reporting and Zipping (shared by both modes) ---
report_and_zip() {
    local original_size="$1"
    local compressed_size="$2"
    local final_file="$3"
    local do_zip="$4"
    
    local final_filename; final_filename=$(basename "${final_file}")

    if [[ "$compressed_size" -ge "$original_size" ]]; then
        echo -e "\n${C_YELLOW}Warning: Final compressed file is not smaller than original(s).${C_RESET}"
        rm "${final_file}"
        echo -e "${C_YELLOW}Deleted the final output file: ${C_BOLD}${final_filename}${C_RESET}"
        exit 0
    fi

    local size_diff=$((original_size - compressed_size))
    local reduction_percent; reduction_percent=$(echo "scale=2; 100 * ${size_diff} / ${original_size}" | bc)

    echo -e "\n${C_GREEN}${C_BOLD}Processing Complete!${C_RESET}"
    echo "---------------------------------"
    echo -e "Original Size (Total): ${C_YELLOW}$(numfmt --to=iec-i --suffix=B --format="%.2f" "$original_size")${C_RESET}"
    echo -e "Compressed Size:       ${C_GREEN}$(numfmt --to=iec-i --suffix=B --format="%.2f" "$compressed_size")${C_RESET}"
    echo -e "Reduction:             ${C_BLUE}${C_BOLD}${reduction_percent}%${C_RESET}"
    echo "---------------------------------"
    echo -e "Final output saved to: ${C_BOLD}${final_filename}${C_RESET}"

    if [[ "$do_zip" -eq 1 ]]; then
        local zip_file="${final_file%.*}.zip"
        if [[ -f "$zip_file" ]]; then
            echo -e "${C_RED}Error: ZIP archive already exists: ${C_BOLD}${zip_file}${C_RESET}"
        else
            echo -e "\n${C_BLUE}Packaging into ZIP archive...${C_RESET}"
            if zip -q -j -m "${zip_file}" "${final_file}"; then
                echo -e "${C_GREEN}Successfully packaged into: ${C_BOLD}${zip_file}${C_RESET}"
            else
                echo -e "${C_RED}Error: Failed to create ZIP archive.${C_RESET}"
            fi
        fi
    fi
}

# --- Script Entry Point ---
main() {
    local do_zip=0
    local dpi="${DEFAULT_DPI}"
    local input_path=""

    if [[ $# -eq 0 ]]; then
        show_usage
        exit 1
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -z|--zip) do_zip=1; shift ;;
            -d|--dpi) dpi="$2"; shift 2 ;;
            -h|--help) show_usage; exit 0 ;;
            -*) echo -e "${C_RED}Error: Unknown option: $1${C_RESET}"; show_usage; exit 1 ;;
            *) input_path="$1"; shift ;;
        esac
    done

    if [[ -z "$input_path" ]]; then
        echo -e "${C_RED}Error: No input file or directory specified.${C_RESET}"
        show_usage
        exit 1
    fi
    
    if [[ ! -e "$input_path" ]]; then
        echo -e "${C_RED}Error: Input path not found: ${C_BOLD}${input_path}${C_RESET}"
        exit 1
    fi

    check_deps

    if [[ -d "$input_path" ]]; then
        process_directory "${input_path}" "${dpi}" "${do_zip}"
    elif [[ -f "$input_path" ]]; then
        process_single_file "${input_path}" "${dpi}" "${do_zip}"
    else
        echo -e "${C_RED}Error: Input path is not a regular file or directory.${C_RESET}"
        exit 1
    fi
}

main "$@"
